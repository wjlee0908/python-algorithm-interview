## 문제 링크
https://leetcode.com/problems/reconstruct-itinerary

# DFS를 이용한 풀이
## 핵심 아이디어
- `[from, to]` 리스트 -> 그래프
- 결과가 방문하는 노드 리스트 -> 그래프 경로 -> 인접 리스트 + DFS -> 재귀

## Note
- 방문 경로는 인접 리스트에 DFS를 적용하여 구할 수 있다
- 인접 리스트는 `collections.defaultdict(list)`로 만든다
- 리스트의 `pop(0)`는 `O(N)`, `pop()`은 `O(1)`이기 때문에 리스트를 역순으로 구성해서 시간 복잡도를 줄일 수 있다

# 반복문을 이용한 풀이
## 핵심 아이디어
- `[from, to]` 리스트 -> 그래프
- - 결과가 방문하는 노드 리스트 -> 그래프 경로 -> 인접 리스트 + DFS -> 스택에 방문 노드 저장하면서 반복
  - 간선이 없으면 결과 리스트에 미리 넣어서 가장 마지막 순서에 방문하도록 한닽

## Note
- DFS를 반복문으로 구현할 때는 방문한 노드를 stack에 저장한다
  - 상위 노드로 다시 올라가는 것은 `stack.pop()`으로 구현한다
  - 인접 행렬에 간선이 있으면 반복문으로 `.append()` 없으면 반복문 탈출해서 `.pop()`
- 입력에 유효한 경로가 반드시 존재한다는 가정이 있으면 막다른 길은 마지막에 방문하게 된다